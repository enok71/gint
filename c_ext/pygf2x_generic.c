/* -*- mode: c; c-basic-offset: 4; -*- */
/*******************************************************************************
 *
 * Copyright (c) 2020 Oskar Enoksson. All rights reserved.
 * Licensed under the MIT license. See LICENSE file in the project root for details.
 *
 * Description:
 * Base (generic) implementation of arithmetic on infinite polynomials over GF(2)
 *
 *******************************************************************************/

#define PY_SSIZE_T_CLEAN
#include <Python.h>

#include <string.h>
#include <stdio.h>

//#define DEBUG_PYGF2X
#ifdef DEBUG_PYGF2X
#define DBG_PRINTF(...) printf(__VA_ARGS__)
#define DBG_PRINTF_DIGITS(msg,digits,ndigs) { DBG_PRINTF(msg); for(int i=ndigs-1; i>=0; i--) DBG_PRINTF("%08x", digits[i]); DBG_PRINTF("\n"); }
#include <execinfo.h>
#define DBG_ASSERT(x) { if (! (x) ) { fprintf(stderr,"Assertion failed on line %d: %s\n",__LINE__,#x); my_abort(); } }
static void my_abort() {
  void *array[3];
  size_t size;

  // get void*'s for all entries on the stack
  size = backtrace(array, 3);

  // print out all the frames to stderr
  backtrace_symbols_fd(array, size, STDERR_FILENO);
  exit(1);
}
#else
#define DBG_PRINTF(...)
#define DBG_PRINTF_DIGITS(...)
#define DBG_ASSERT(x)
#endif

#define BITS_PER_DIGIT PyLong_SHIFT
static const int N5_PER_DIGIT = sizeof(digit)*8*3/16;
static const int N15_PER_DIGIT = sizeof(digit)*8/16;
#define GF2X_MAX(a,b) ((a>b) ? (a) : (b))
#define GF2X_MIN(a,b) ((a<b) ? (a) : (b))

static const int LIMIT_DIV_BITWISE = 5;
//#define USE_KARATSUBA_15_15
#define NDIV 10
#define inv_NDIV inv_10

// Squares up to 255x255 (8-bit chunk size)
static const uint16_t sqr_8[256] = {
    0x0000,0x0001,0x0004,0x0005,0x0010,0x0011,0x0014,0x0015,0x0040,0x0041,0x0044,0x0045,0x0050,0x0051,0x0054,0x0055,
    0x0100,0x0101,0x0104,0x0105,0x0110,0x0111,0x0114,0x0115,0x0140,0x0141,0x0144,0x0145,0x0150,0x0151,0x0154,0x0155,
    0x0400,0x0401,0x0404,0x0405,0x0410,0x0411,0x0414,0x0415,0x0440,0x0441,0x0444,0x0445,0x0450,0x0451,0x0454,0x0455,
    0x0500,0x0501,0x0504,0x0505,0x0510,0x0511,0x0514,0x0515,0x0540,0x0541,0x0544,0x0545,0x0550,0x0551,0x0554,0x0555,
    0x1000,0x1001,0x1004,0x1005,0x1010,0x1011,0x1014,0x1015,0x1040,0x1041,0x1044,0x1045,0x1050,0x1051,0x1054,0x1055,
    0x1100,0x1101,0x1104,0x1105,0x1110,0x1111,0x1114,0x1115,0x1140,0x1141,0x1144,0x1145,0x1150,0x1151,0x1154,0x1155,
    0x1400,0x1401,0x1404,0x1405,0x1410,0x1411,0x1414,0x1415,0x1440,0x1441,0x1444,0x1445,0x1450,0x1451,0x1454,0x1455,
    0x1500,0x1501,0x1504,0x1505,0x1510,0x1511,0x1514,0x1515,0x1540,0x1541,0x1544,0x1545,0x1550,0x1551,0x1554,0x1555,
    0x4000,0x4001,0x4004,0x4005,0x4010,0x4011,0x4014,0x4015,0x4040,0x4041,0x4044,0x4045,0x4050,0x4051,0x4054,0x4055,
    0x4100,0x4101,0x4104,0x4105,0x4110,0x4111,0x4114,0x4115,0x4140,0x4141,0x4144,0x4145,0x4150,0x4151,0x4154,0x4155,
    0x4400,0x4401,0x4404,0x4405,0x4410,0x4411,0x4414,0x4415,0x4440,0x4441,0x4444,0x4445,0x4450,0x4451,0x4454,0x4455,
    0x4500,0x4501,0x4504,0x4505,0x4510,0x4511,0x4514,0x4515,0x4540,0x4541,0x4544,0x4545,0x4550,0x4551,0x4554,0x4555,
    0x5000,0x5001,0x5004,0x5005,0x5010,0x5011,0x5014,0x5015,0x5040,0x5041,0x5044,0x5045,0x5050,0x5051,0x5054,0x5055,
    0x5100,0x5101,0x5104,0x5105,0x5110,0x5111,0x5114,0x5115,0x5140,0x5141,0x5144,0x5145,0x5150,0x5151,0x5154,0x5155,
    0x5400,0x5401,0x5404,0x5405,0x5410,0x5411,0x5414,0x5415,0x5440,0x5441,0x5444,0x5445,0x5450,0x5451,0x5454,0x5455,
    0x5500,0x5501,0x5504,0x5505,0x5510,0x5511,0x5514,0x5515,0x5540,0x5541,0x5544,0x5545,0x5550,0x5551,0x5554,0x5555,
};


// Multiplication table up to 31x31, that is, 5-bit chunks.
static const uint16_t mul_5_5[32][32] = {
    {0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,
     0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000,0x000},
    {0x000,0x001,0x002,0x003,0x004,0x005,0x006,0x007,0x008,0x009,0x00a,0x00b,0x00c,0x00d,0x00e,0x00f,
     0x010,0x011,0x012,0x013,0x014,0x015,0x016,0x017,0x018,0x019,0x01a,0x01b,0x01c,0x01d,0x01e,0x01f},
    {0x000,0x002,0x004,0x006,0x008,0x00a,0x00c,0x00e,0x010,0x012,0x014,0x016,0x018,0x01a,0x01c,0x01e,
     0x020,0x022,0x024,0x026,0x028,0x02a,0x02c,0x02e,0x030,0x032,0x034,0x036,0x038,0x03a,0x03c,0x03e},
    {0x000,0x003,0x006,0x005,0x00c,0x00f,0x00a,0x009,0x018,0x01b,0x01e,0x01d,0x014,0x017,0x012,0x011,
     0x030,0x033,0x036,0x035,0x03c,0x03f,0x03a,0x039,0x028,0x02b,0x02e,0x02d,0x024,0x027,0x022,0x021},
    {0x000,0x004,0x008,0x00c,0x010,0x014,0x018,0x01c,0x020,0x024,0x028,0x02c,0x030,0x034,0x038,0x03c,
     0x040,0x044,0x048,0x04c,0x050,0x054,0x058,0x05c,0x060,0x064,0x068,0x06c,0x070,0x074,0x078,0x07c},
    {0x000,0x005,0x00a,0x00f,0x014,0x011,0x01e,0x01b,0x028,0x02d,0x022,0x027,0x03c,0x039,0x036,0x033,
     0x050,0x055,0x05a,0x05f,0x044,0x041,0x04e,0x04b,0x078,0x07d,0x072,0x077,0x06c,0x069,0x066,0x063},
    {0x000,0x006,0x00c,0x00a,0x018,0x01e,0x014,0x012,0x030,0x036,0x03c,0x03a,0x028,0x02e,0x024,0x022,
     0x060,0x066,0x06c,0x06a,0x078,0x07e,0x074,0x072,0x050,0x056,0x05c,0x05a,0x048,0x04e,0x044,0x042},
    {0x000,0x007,0x00e,0x009,0x01c,0x01b,0x012,0x015,0x038,0x03f,0x036,0x031,0x024,0x023,0x02a,0x02d,
     0x070,0x077,0x07e,0x079,0x06c,0x06b,0x062,0x065,0x048,0x04f,0x046,0x041,0x054,0x053,0x05a,0x05d},
    {0x000,0x008,0x010,0x018,0x020,0x028,0x030,0x038,0x040,0x048,0x050,0x058,0x060,0x068,0x070,0x078,
     0x080,0x088,0x090,0x098,0x0a0,0x0a8,0x0b0,0x0b8,0x0c0,0x0c8,0x0d0,0x0d8,0x0e0,0x0e8,0x0f0,0x0f8},
    {0x000,0x009,0x012,0x01b,0x024,0x02d,0x036,0x03f,0x048,0x041,0x05a,0x053,0x06c,0x065,0x07e,0x077,
     0x090,0x099,0x082,0x08b,0x0b4,0x0bd,0x0a6,0x0af,0x0d8,0x0d1,0x0ca,0x0c3,0x0fc,0x0f5,0x0ee,0x0e7},
    {0x000,0x00a,0x014,0x01e,0x028,0x022,0x03c,0x036,0x050,0x05a,0x044,0x04e,0x078,0x072,0x06c,0x066,
     0x0a0,0x0aa,0x0b4,0x0be,0x088,0x082,0x09c,0x096,0x0f0,0x0fa,0x0e4,0x0ee,0x0d8,0x0d2,0x0cc,0x0c6},
    {0x000,0x00b,0x016,0x01d,0x02c,0x027,0x03a,0x031,0x058,0x053,0x04e,0x045,0x074,0x07f,0x062,0x069,
     0x0b0,0x0bb,0x0a6,0x0ad,0x09c,0x097,0x08a,0x081,0x0e8,0x0e3,0x0fe,0x0f5,0x0c4,0x0cf,0x0d2,0x0d9},
    {0x000,0x00c,0x018,0x014,0x030,0x03c,0x028,0x024,0x060,0x06c,0x078,0x074,0x050,0x05c,0x048,0x044,
     0x0c0,0x0cc,0x0d8,0x0d4,0x0f0,0x0fc,0x0e8,0x0e4,0x0a0,0x0ac,0x0b8,0x0b4,0x090,0x09c,0x088,0x084},
    {0x000,0x00d,0x01a,0x017,0x034,0x039,0x02e,0x023,0x068,0x065,0x072,0x07f,0x05c,0x051,0x046,0x04b,
     0x0d0,0x0dd,0x0ca,0x0c7,0x0e4,0x0e9,0x0fe,0x0f3,0x0b8,0x0b5,0x0a2,0x0af,0x08c,0x081,0x096,0x09b},
    {0x000,0x00e,0x01c,0x012,0x038,0x036,0x024,0x02a,0x070,0x07e,0x06c,0x062,0x048,0x046,0x054,0x05a,
     0x0e0,0x0ee,0x0fc,0x0f2,0x0d8,0x0d6,0x0c4,0x0ca,0x090,0x09e,0x08c,0x082,0x0a8,0x0a6,0x0b4,0x0ba},
    {0x000,0x00f,0x01e,0x011,0x03c,0x033,0x022,0x02d,0x078,0x077,0x066,0x069,0x044,0x04b,0x05a,0x055,
     0x0f0,0x0ff,0x0ee,0x0e1,0x0cc,0x0c3,0x0d2,0x0dd,0x088,0x087,0x096,0x099,0x0b4,0x0bb,0x0aa,0x0a5},
    {0x000,0x010,0x020,0x030,0x040,0x050,0x060,0x070,0x080,0x090,0x0a0,0x0b0,0x0c0,0x0d0,0x0e0,0x0f0,
     0x100,0x110,0x120,0x130,0x140,0x150,0x160,0x170,0x180,0x190,0x1a0,0x1b0,0x1c0,0x1d0,0x1e0,0x1f0},
    {0x000,0x011,0x022,0x033,0x044,0x055,0x066,0x077,0x088,0x099,0x0aa,0x0bb,0x0cc,0x0dd,0x0ee,0x0ff,
     0x110,0x101,0x132,0x123,0x154,0x145,0x176,0x167,0x198,0x189,0x1ba,0x1ab,0x1dc,0x1cd,0x1fe,0x1ef},
    {0x000,0x012,0x024,0x036,0x048,0x05a,0x06c,0x07e,0x090,0x082,0x0b4,0x0a6,0x0d8,0x0ca,0x0fc,0x0ee,
     0x120,0x132,0x104,0x116,0x168,0x17a,0x14c,0x15e,0x1b0,0x1a2,0x194,0x186,0x1f8,0x1ea,0x1dc,0x1ce},
    {0x000,0x013,0x026,0x035,0x04c,0x05f,0x06a,0x079,0x098,0x08b,0x0be,0x0ad,0x0d4,0x0c7,0x0f2,0x0e1,
     0x130,0x123,0x116,0x105,0x17c,0x16f,0x15a,0x149,0x1a8,0x1bb,0x18e,0x19d,0x1e4,0x1f7,0x1c2,0x1d1},
    {0x000,0x014,0x028,0x03c,0x050,0x044,0x078,0x06c,0x0a0,0x0b4,0x088,0x09c,0x0f0,0x0e4,0x0d8,0x0cc,
     0x140,0x154,0x168,0x17c,0x110,0x104,0x138,0x12c,0x1e0,0x1f4,0x1c8,0x1dc,0x1b0,0x1a4,0x198,0x18c},
    {0x000,0x015,0x02a,0x03f,0x054,0x041,0x07e,0x06b,0x0a8,0x0bd,0x082,0x097,0x0fc,0x0e9,0x0d6,0x0c3,
     0x150,0x145,0x17a,0x16f,0x104,0x111,0x12e,0x13b,0x1f8,0x1ed,0x1d2,0x1c7,0x1ac,0x1b9,0x186,0x193},
    {0x000,0x016,0x02c,0x03a,0x058,0x04e,0x074,0x062,0x0b0,0x0a6,0x09c,0x08a,0x0e8,0x0fe,0x0c4,0x0d2,
     0x160,0x176,0x14c,0x15a,0x138,0x12e,0x114,0x102,0x1d0,0x1c6,0x1fc,0x1ea,0x188,0x19e,0x1a4,0x1b2},
    {0x000,0x017,0x02e,0x039,0x05c,0x04b,0x072,0x065,0x0b8,0x0af,0x096,0x081,0x0e4,0x0f3,0x0ca,0x0dd,
     0x170,0x167,0x15e,0x149,0x12c,0x13b,0x102,0x115,0x1c8,0x1df,0x1e6,0x1f1,0x194,0x183,0x1ba,0x1ad},
    {0x000,0x018,0x030,0x028,0x060,0x078,0x050,0x048,0x0c0,0x0d8,0x0f0,0x0e8,0x0a0,0x0b8,0x090,0x088,
     0x180,0x198,0x1b0,0x1a8,0x1e0,0x1f8,0x1d0,0x1c8,0x140,0x158,0x170,0x168,0x120,0x138,0x110,0x108},
    {0x000,0x019,0x032,0x02b,0x064,0x07d,0x056,0x04f,0x0c8,0x0d1,0x0fa,0x0e3,0x0ac,0x0b5,0x09e,0x087,
     0x190,0x189,0x1a2,0x1bb,0x1f4,0x1ed,0x1c6,0x1df,0x158,0x141,0x16a,0x173,0x13c,0x125,0x10e,0x117},
    {0x000,0x01a,0x034,0x02e,0x068,0x072,0x05c,0x046,0x0d0,0x0ca,0x0e4,0x0fe,0x0b8,0x0a2,0x08c,0x096,
     0x1a0,0x1ba,0x194,0x18e,0x1c8,0x1d2,0x1fc,0x1e6,0x170,0x16a,0x144,0x15e,0x118,0x102,0x12c,0x136},
    {0x000,0x01b,0x036,0x02d,0x06c,0x077,0x05a,0x041,0x0d8,0x0c3,0x0ee,0x0f5,0x0b4,0x0af,0x082,0x099,
     0x1b0,0x1ab,0x186,0x19d,0x1dc,0x1c7,0x1ea,0x1f1,0x168,0x173,0x15e,0x145,0x104,0x11f,0x132,0x129},
    {0x000,0x01c,0x038,0x024,0x070,0x06c,0x048,0x054,0x0e0,0x0fc,0x0d8,0x0c4,0x090,0x08c,0x0a8,0x0b4,
     0x1c0,0x1dc,0x1f8,0x1e4,0x1b0,0x1ac,0x188,0x194,0x120,0x13c,0x118,0x104,0x150,0x14c,0x168,0x174},
    {0x000,0x01d,0x03a,0x027,0x074,0x069,0x04e,0x053,0x0e8,0x0f5,0x0d2,0x0cf,0x09c,0x081,0x0a6,0x0bb,
     0x1d0,0x1cd,0x1ea,0x1f7,0x1a4,0x1b9,0x19e,0x183,0x138,0x125,0x102,0x11f,0x14c,0x151,0x176,0x16b},
    {0x000,0x01e,0x03c,0x022,0x078,0x066,0x044,0x05a,0x0f0,0x0ee,0x0cc,0x0d2,0x088,0x096,0x0b4,0x0aa,
     0x1e0,0x1fe,0x1dc,0x1c2,0x198,0x186,0x1a4,0x1ba,0x110,0x10e,0x12c,0x132,0x168,0x176,0x154,0x14a},
    {0x000,0x01f,0x03e,0x021,0x07c,0x063,0x042,0x05d,0x0f8,0x0e7,0x0c6,0x0d9,0x084,0x09b,0x0ba,0x0a5,
     0x1f0,0x1ef,0x1ce,0x1d1,0x18c,0x193,0x1b2,0x1ad,0x108,0x117,0x136,0x129,0x174,0x16b,0x14a,0x155},
};


// Inverse table for 2^(N-1)..2^N-1, N-bit denominators with msb=1.
// Table lists inv(d) where
// 1<<(2N-2) + rem(d) == inv(d)*d
// inv(d) is N-bits (msb always=1) and rem(d) is N-1 bits
// To perform division: seek q and r such that
// u = q*d +r
// were u is 2N-1 bits and d is N bits (d has msb=1). q is N bits and r is N-1 bits
// u*inv(d) = q*d*inv(d) + r*inv(d)
//          = (q<<(2N-2)) + q*rem(d) + r*inv(d)
// The highest N bits of u*inv(d) must be q, because the other terms are <=2N-2 bits
//
/*
static const uint8_t inv_8[1<<7] = {
  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x92,0x93,0x90,0x91,0x96,0x97,0x94,0x95,0x9a,0x9b,0x98,0x99,0x9e,0x9f,0x9c,0x9d,
  0xaa,0xab,0xa8,0xa9,0xae,0xaf,0xac,0xad,0xa2,0xa3,0xa0,0xa1,0xa6,0xa7,0xa4,0xa5,0xb9,0xb8,0xbb,0xba,0xbd,0xbc,0xbf,0xbe,0xb1,0xb0,0xb3,0xb2,0xb5,0xb4,0xb7,0xb6,
  0xff,0xfe,0xfd,0xfc,0xfa,0xfb,0xf8,0xf9,0xf5,0xf4,0xf7,0xf6,0xf0,0xf1,0xf2,0xf3,0xe9,0xe8,0xeb,0xea,0xec,0xed,0xee,0xef,0xe3,0xe2,0xe1,0xe0,0xe6,0xe7,0xe4,0xe5,
  0xdb,0xda,0xd9,0xd8,0xde,0xdf,0xdc,0xdd,0xd1,0xd0,0xd3,0xd2,0xd4,0xd5,0xd6,0xd7,0xcc,0xcd,0xce,0xcf,0xc9,0xc8,0xcb,0xca,0xc6,0xc7,0xc4,0xc5,0xc3,0xc2,0xc1,0xc0,
};
*/
static const uint16_t inv_10[1<<9] = {
    0x200,0x201,0x202,0x203,0x204,0x205,0x206,0x207,0x208,0x209,0x20a,0x20b,0x20c,0x20d,0x20e,0x20f,
    0x210,0x211,0x212,0x213,0x214,0x215,0x216,0x217,0x218,0x219,0x21a,0x21b,0x21c,0x21d,0x21e,0x21f,
    0x222,0x223,0x220,0x221,0x226,0x227,0x224,0x225,0x22a,0x22b,0x228,0x229,0x22e,0x22f,0x22c,0x22d,
    0x232,0x233,0x230,0x231,0x236,0x237,0x234,0x235,0x23a,0x23b,0x238,0x239,0x23e,0x23f,0x23c,0x23d,
    0x249,0x248,0x24b,0x24a,0x24d,0x24c,0x24f,0x24e,0x241,0x240,0x243,0x242,0x245,0x244,0x247,0x246,
    0x259,0x258,0x25b,0x25a,0x25d,0x25c,0x25f,0x25e,0x251,0x250,0x253,0x252,0x255,0x254,0x257,0x256,
    0x26b,0x26a,0x269,0x268,0x26f,0x26e,0x26d,0x26c,0x263,0x262,0x261,0x260,0x267,0x266,0x265,0x264,
    0x27b,0x27a,0x279,0x278,0x27f,0x27e,0x27d,0x27c,0x273,0x272,0x271,0x270,0x277,0x276,0x275,0x274,
    0x2aa,0x2ab,0x2a8,0x2a9,0x2ae,0x2af,0x2ac,0x2ad,0x2a2,0x2a3,0x2a0,0x2a1,0x2a6,0x2a7,0x2a4,0x2a5,
    0x2bb,0x2ba,0x2b9,0x2b8,0x2bf,0x2be,0x2bd,0x2bc,0x2b3,0x2b2,0x2b1,0x2b0,0x2b7,0x2b6,0x2b5,0x2b4,
    0x28a,0x28b,0x288,0x289,0x28e,0x28f,0x28c,0x28d,0x282,0x283,0x280,0x281,0x286,0x287,0x284,0x285,
    0x29b,0x29a,0x299,0x298,0x29f,0x29e,0x29d,0x29c,0x293,0x292,0x291,0x290,0x297,0x296,0x295,0x294,
    0x2e5,0x2e4,0x2e7,0x2e6,0x2e1,0x2e0,0x2e3,0x2e2,0x2ed,0x2ec,0x2ef,0x2ee,0x2e9,0x2e8,0x2eb,0x2ea,
    0x2f4,0x2f5,0x2f6,0x2f7,0x2f0,0x2f1,0x2f2,0x2f3,0x2fc,0x2fd,0x2fe,0x2ff,0x2f8,0x2f9,0x2fa,0x2fb,
    0x2c5,0x2c4,0x2c7,0x2c6,0x2c1,0x2c0,0x2c3,0x2c2,0x2cd,0x2cc,0x2cf,0x2ce,0x2c9,0x2c8,0x2cb,0x2ca,
    0x2d4,0x2d5,0x2d6,0x2d7,0x2d0,0x2d1,0x2d2,0x2d3,0x2dc,0x2dd,0x2de,0x2df,0x2d8,0x2d9,0x2da,0x2db,
    0x3ff,0x3fe,0x3fd,0x3fc,0x3fa,0x3fb,0x3f8,0x3f9,0x3f5,0x3f4,0x3f7,0x3f6,0x3f0,0x3f1,0x3f2,0x3f3,
    0x3ea,0x3eb,0x3e8,0x3e9,0x3ef,0x3ee,0x3ed,0x3ec,0x3e0,0x3e1,0x3e2,0x3e3,0x3e5,0x3e4,0x3e7,0x3e6,
    0x3d6,0x3d7,0x3d4,0x3d5,0x3d3,0x3d2,0x3d1,0x3d0,0x3dc,0x3dd,0x3de,0x3df,0x3d9,0x3d8,0x3db,0x3da,
    0x3c3,0x3c2,0x3c1,0x3c0,0x3c6,0x3c7,0x3c4,0x3c5,0x3c9,0x3c8,0x3cb,0x3ca,0x3cc,0x3cd,0x3ce,0x3cf,
    0x3a7,0x3a6,0x3a5,0x3a4,0x3a2,0x3a3,0x3a0,0x3a1,0x3ad,0x3ac,0x3af,0x3ae,0x3a8,0x3a9,0x3aa,0x3ab,
    0x3b2,0x3b3,0x3b0,0x3b1,0x3b7,0x3b6,0x3b5,0x3b4,0x3b8,0x3b9,0x3ba,0x3bb,0x3bd,0x3bc,0x3bf,0x3be,
    0x38e,0x38f,0x38c,0x38d,0x38b,0x38a,0x389,0x388,0x384,0x385,0x386,0x387,0x381,0x380,0x383,0x382,
    0x39b,0x39a,0x399,0x398,0x39e,0x39f,0x39c,0x39d,0x391,0x390,0x393,0x392,0x394,0x395,0x396,0x397,
    0x36d,0x36c,0x36f,0x36e,0x368,0x369,0x36a,0x36b,0x367,0x366,0x365,0x364,0x362,0x363,0x360,0x361,
    0x379,0x378,0x37b,0x37a,0x37c,0x37d,0x37e,0x37f,0x373,0x372,0x371,0x370,0x376,0x377,0x374,0x375,
    0x346,0x347,0x344,0x345,0x343,0x342,0x341,0x340,0x34c,0x34d,0x34e,0x34f,0x349,0x348,0x34b,0x34a,
    0x352,0x353,0x350,0x351,0x357,0x356,0x355,0x354,0x358,0x359,0x35a,0x35b,0x35d,0x35c,0x35f,0x35e,
    0x333,0x332,0x331,0x330,0x336,0x337,0x334,0x335,0x339,0x338,0x33b,0x33a,0x33c,0x33d,0x33e,0x33f,
    0x327,0x326,0x325,0x324,0x322,0x323,0x320,0x321,0x32d,0x32c,0x32f,0x32e,0x328,0x329,0x32a,0x32b,
    0x318,0x319,0x31a,0x31b,0x31d,0x31c,0x31f,0x31e,0x312,0x313,0x310,0x311,0x317,0x316,0x315,0x314,
    0x30c,0x30d,0x30e,0x30f,0x309,0x308,0x30b,0x30a,0x306,0x307,0x304,0x305,0x303,0x302,0x301,0x300,
};

static inline int nbits(PyLongObject *integer) {
    // return 1-based index of the most significant non-zero bit, or 0 if all bits are zero
    return _PyLong_NumBits((PyObject *)integer);
}

static uint32_t
mul_15_15(uint16_t l, uint16_t r)
// Multiply two unsigned 15-bit polynomials over GF(2) (stored in uint16_t)
// Return as a 29-bit polynomial (stored in uint32_t)
{
    uint8_t l0 = l & 0x1f;
    l>>=5;
    uint8_t l1 = l&0x1f;
    l>>=5;
    uint8_t l2 = l&0x1f;
    uint8_t r0 = r&0x1f;
    r>>=5;
    uint8_t r1 = r&0x1f;
    r>>=5;
    uint8_t r2 = r&0x1f;

#ifdef USE_KARATSUBA_15_15
    // The following is the result of applying Karatsuba
    // twice on a 3-digit representation.
    uint8_t l01   = l0^l1;
    uint8_t r01   = r0^r1;
    uint8_t l12   = l1^l2;
    uint8_t r12   = r1^r2;
    uint8_t l012  = l01^l2;
    uint8_t r012  = r01^r2;
    uint16_t p0   = mul_5_5[l0][r0];
    uint16_t p1   = mul_5_5[l1][r1];
    uint16_t p2   = mul_5_5[l2][r2];
    uint16_t p01  = mul_5_5[l01][r01];
    uint16_t p12  = mul_5_5[l12][r12];
    uint16_t p012 = mul_5_5[l012][r012];
    uint32_t p = p2;
    p <<= 5;
    p ^= p12 ^ p1 ^ p2;
    p <<= 5;
    p ^= p012 ^ p01 ^ p12; // The term p1^p1 cancels out here thanks to Gallois arithmetic
    p <<= 5;
    p ^= p01 ^ p1 ^ p0;
    p <<= 5;
    p ^= p0;
    // 6 mul + 12 add
#else
    uint32_t p = mul_5_5[l2][r2];
    p <<= 5;
    p ^= mul_5_5[l1][r2] ^ mul_5_5[l2][r1];
    p <<= 5;
    p ^= mul_5_5[l0][r2] ^ mul_5_5[l1][r1] ^ mul_5_5[l2][r0];
    p <<= 5;
    p ^= mul_5_5[l0][r1] ^ mul_5_5[l1][r0];
    p <<= 5;
    p ^= mul_5_5[l0][r0];
    // 9 mul + 4 add
#endif   
    return p;
}

static uint64_t
mul_30_30(uint32_t l, uint32_t r) 
// Multiply two unsigned 30-bit polynomials over GF(2) (stored in uint32_t)
// Return as a 59-bit polynomial (stored in uint64_t)
// Uses Karatsubas formula
{
    uint16_t ll = l &0x7fff;
    uint16_t lh = (l >> 15) &0x7fff;
    uint16_t rl = r &0x7fff;
    uint16_t rh = (r >> 15) &0x7fff;

    uint32_t z0 = mul_15_15(ll,rl);
    uint32_t z2 = mul_15_15(lh,rh);
    uint32_t z1 = mul_15_15(ll ^ lh, rl ^ rh) ^z2 ^z0;

    return ((((uint64_t)z2 << 15) ^ (uint64_t)z1 ) << 15) ^ (uint64_t)z0;
}


static PyObject *
pygf2x_sqr(PyObject *self, PyObject *args) {
    // Square one Python integer, interpreted as polynomial over GF(2)
    (void)self;

    PyLongObject *f;
    if (!PyArg_ParseTuple(args, "O", &f)) {
        PyErr_SetString(PyExc_TypeError, "Failed to parse arguments");
        return NULL;
    }

    if( ! PyLong_Check(f) ) {
        PyErr_SetString(PyExc_TypeError, "Arguments must be integer");
        return NULL;
    }
    if(((PyVarObject *)f)->ob_size < 0) {
        PyErr_SetString(PyExc_ValueError, "Argument must be non-negative");
        return NULL;
    }

    int nbits_f = nbits(f);
    int nbits_p = 2*nbits_f -1;

    int n15_f = (nbits_f + 14)/15;

    int ndigs_p = (nbits_p + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    PyLongObject *p = _PyLong_New(ndigs_p);
    digit *restrict result = p->ob_digit;
    memset(result,0,ndigs_p*sizeof(digit));
    
    DBG_PRINTF("Bits per digit   = %-4d\n",BITS_PER_DIGIT);
    DBG_PRINTF("factor bits      = %-4d\n",nbits_f);
    DBG_PRINTF("Square digits    = %-4d\n",ndigs_p);

    for(int i15_f=0; i15_f<n15_f; i15_f++) {
        uint16_t ph = 0, pl = 0;
	int id_f   = i15_f/N15_PER_DIGIT;
	int i15d_f = i15_f%N15_PER_DIGIT;
	uint16_t f15 = (f->ob_digit[id_f] >> (15*i15d_f)) & 0x7fff;
	pl = sqr_8[f15 & 0xff];               // The least significant 15 bits
	ph = sqr_8[(f15 >> 8) & 0x7f] << 1;   // The most significant 14 bits

	int i15_p  = 2*i15_f;
	int i15_p_ = i15_p+1;
	result[(i15_p )/N15_PER_DIGIT] ^= ((digit)pl<<(15*((i15_p )%N15_PER_DIGIT)));
	if(ph)
	    result[(i15_p_)/N15_PER_DIGIT] ^= ((digit)ph<<(15*((i15_p_)%N15_PER_DIGIT)));
    }

    DBG_PRINTF_DIGITS("Square:",result,ndigs_p);

    return (PyObject *)p;
}


static PyObject *
pygf2x_mul(PyObject *self, PyObject *args) {
    // Multiply two Python integers, interpreted as polynomials over GF(2)
    (void)self;

    PyLongObject *fl, *fr;
    if (!PyArg_ParseTuple(args, "OO", &fl, &fr)) {
        PyErr_SetString(PyExc_TypeError, "Failed to parse arguments");
        return NULL;
    }

    if( ! PyLong_Check(fl) ||
	! PyLong_Check(fr) ) {
        PyErr_SetString(PyExc_TypeError, "Both arguments must be integers");
        return NULL;
    }
    if(((PyVarObject *)fl)->ob_size < 0 ||
       ((PyVarObject *)fr)->ob_size < 0) {
        PyErr_SetString(PyExc_ValueError, "Both arguments must be non-negative");
        return NULL;
    }

    int nbits_l = nbits(fl);
    int nbits_r = nbits(fr);
    int nbits_p = nbits_l + nbits_r -1;
    int ndigs_l = (nbits_l + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    int ndigs_r = (nbits_r + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    int ndigs_p = (nbits_p + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;

    int n5_l = (nbits_l+4)/5;
    int n5_r = (nbits_r+4)/5;
    int n5_p = n5_l + n5_r -1;

    digit result[ndigs_l + ndigs_r -1];
    memset(result,0,ndigs_p*sizeof(digit));
    
    DBG_PRINTF("Bits per digit   = %-4d\n",BITS_PER_DIGIT);
    DBG_PRINTF("Left factor bits = %-4d\n",nbits_l);
    DBG_PRINTF("Right factor bits= %-4d\n",nbits_r);
    DBG_PRINTF("Product digits   = %-4d\n",ndigs_p);

    const digit *restrict const digits_l = fl->ob_digit;
    const digit *restrict const digits_r = fr->ob_digit;

    for(int id_l=0; id_l<ndigs_l; id_l++) {
	for(int id_r=0; id_r<ndigs_r; id_r++) {
	    digit ld = digits_l[id_l];
	    digit rd = digits_r[id_r];
#if (BITS_PER_DIGIT == 15)
	    twodigits pc = mul_15_15(ld,rd);
#elif (BITS_PER_DIGIT == 30)		
	    twodigits pc = mul_30_30(ld,rd);
#else
#error
#endif
	    result[id_l+id_r  ] ^= (digit)pc & PyLong_MASK;
	    result[id_l+id_r+1] ^= pc >> (digit)BITS_PER_DIGIT;
	}
    }

    DBG_PRINTF_DIGITS("Product          :",result,ndigs_p);

    PyLongObject *p = _PyLong_New(ndigs_p);
    for(int n=0; n<ndigs_p; n++)
	p->ob_digit[n] = result[n];

    return (PyObject *)p;
}

static inline uint16_t extract_chunk(const digit *digits, int ib, int nch, const int ndigs)
// return nch-bit chunk of data extracted from digits, at msbit position ib.
// Max value for nch is 15 because BITS_PER_DIGIT can be 15
{
    DBG_ASSERT(nch <= 15);
    DBG_ASSERT(nch <= BITS_PER_DIGIT);
    DBG_ASSERT(nch-1 <= ib);
    DBG_ASSERT(ib < BITS_PER_DIGIT*ndigs);
    int id  = ib/BITS_PER_DIGIT;  // Digit position of most significant bit
    int ibd = ib%BITS_PER_DIGIT;  // Bit position in digit
    uint16_t ch;
    if(ibd >= nch-1) {
	// The chunk is contained in one single digit
	DBG_ASSERT(id >=0 && id < ndigs);
	ch = digits[id] >> (ibd - (nch-1));
    } else {
	// The chunk is split between two digits
	DBG_ASSERT(id >=1 && id < ndigs);
	ch = (digits[id  ] << ((nch-1) - ibd))
	    |(digits[id-1] >> (BITS_PER_DIGIT - ((nch-1) - ibd)));
    }
    return ch;
}

static inline void add_chunk(digit *digits, int ib, int nch, uint16_t value, const int ndigs)
// Add (xor) nch-bit chunk of data to digits, at msbit position ib.
// Max value for nch is 15 because BITS_PER_DIGIT can be 15
{
    DBG_ASSERT(nch <= 15);
    DBG_ASSERT(nch <= BITS_PER_DIGIT);
    DBG_ASSERT(nch-1 <= ib);
    DBG_ASSERT(ib < BITS_PER_DIGIT*ndigs);
    DBG_ASSERT(value < (1<<nch));
    int id  = ib/BITS_PER_DIGIT;  // Digit position of most significant bit
    int ibd = ib%BITS_PER_DIGIT;  // Bit position in digit
    if(ibd >= nch-1) {
	// The chunk is contained in one single digit
	DBG_ASSERT(id >=0 && id < ndigs);
	digits[id] ^= value << (ibd - (nch-1));
    } else {
	// The chunk is split between two digits
	DBG_ASSERT(id >=1 && id < ndigs);
	digits[id  ] ^= value >> ((nch-1) - ibd);
	digits[id-1] ^= (value & ((1 << ((nch-1) - ibd)) - 1 )) << (BITS_PER_DIGIT - ((nch-1) - ibd));
    }
}

static PyObject *
pygf2x_div(PyObject *self, PyObject *args)
// Divide two Python integers, interpreted as polynomials over GF(2)
// Return quotient and remainder
{
    (void)self;

    PyLongObject *numerator, *denominator;
    if (!PyArg_ParseTuple(args, "OO", &numerator, &denominator)) {
        PyErr_SetString(PyExc_TypeError, "Failed to parse arguments");
        return NULL;
    }
    
    if( ! PyLong_Check(numerator) ||
        ! PyLong_Check(denominator) ) {
        PyErr_SetString(PyExc_TypeError, "Both arguments must be integers");
        return NULL;
    }
    if(((PyVarObject *)numerator)->ob_size < 0 ||
       ((PyVarObject *)denominator)->ob_size < 0) {
        PyErr_SetString(PyExc_ValueError, "Both arguments must be non-negative");
        return NULL;
    }

    int nbits_d = nbits(denominator);
    int ndigs_d = (nbits_d + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    if(nbits_d == 0) {
        PyErr_SetString(PyExc_ZeroDivisionError, "Denominator is zero");
        return NULL;
    }
    int nbits_n = nbits(numerator);
    int ndigs_n = (nbits_n + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    
    int nbits_q = nbits_n > nbits_d-1 ? nbits_n - (nbits_d-1) : 0;
    int nbits_r = nbits_n > nbits_d-1 ? nbits_n : nbits_d-1;
    int ndigs_q = (nbits_q + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;
    int ndigs_r = (nbits_r + (BITS_PER_DIGIT-1))/BITS_PER_DIGIT;

    
    PyLongObject *q = _PyLong_New(ndigs_q);
    digit *restrict q_digits = q->ob_digit;
    memset(q_digits,0,ndigs_q*sizeof(digit));
    
    digit r_digits[ndigs_r]; // Initialize to numerator
    memset(r_digits+ndigs_n,0,(ndigs_r-ndigs_n)*sizeof(digit));
    memcpy(r_digits, numerator->ob_digit, ndigs_n*sizeof(digit));
    
    DBG_PRINTF("Bits per digit   = %-4d\n",BITS_PER_DIGIT);
    DBG_PRINTF("Numerator bits   = %-4d\n",nbits_n);
    DBG_PRINTF("Denominator bits = %-4d\n",nbits_d);
    DBG_PRINTF("Quotient bits    = %-4d\n",nbits_q);
    DBG_PRINTF("Remainder bits  <= %-4d\n",nbits_r);

    DBG_PRINTF_DIGITS("Numerator        :",numerator->ob_digit,ndigs_n);
    DBG_PRINTF_DIGITS("Denominator      :",denominator->ob_digit,ndigs_d);
    
    if(nbits_d < LIMIT_DIV_BITWISE) {
        // Use bitwise Euclidean division for small denominators because it is possibly more efficient
	for(int ib_r = nbits_n-1; ib_r >= nbits_d-1; ib_r--) {
	    int id_r = (ib_r/BITS_PER_DIGIT);    // Digit position
	    int ibd_r = ib_r-id_r*BITS_PER_DIGIT; // Bit position in digit
	    if(r_digits[id_r] & (1<<ibd_r)) {
		// Numerator bit is set. Set quotient bit and subtract denominator
		int ib_q  = ib_r - nbits_d +1;
		int id_q  = ib_q/BITS_PER_DIGIT;       // Digit position
		int ibd_q = ib_q%BITS_PER_DIGIT;       // Bit position in digit
		q_digits[id_q] |= (1<<ibd_q);
		for(int ib_d  = nbits_d-1; ib_d >= 0 ; ib_d--) {
		    int id_d  = ib_d/BITS_PER_DIGIT;   // Digit position
		    int ibd_d = ib_d%BITS_PER_DIGIT;   // Bit position in digit
		    int ib_dr  = ib_r - ((nbits_d-1) - ib_d);
		    int id_dr  = ib_dr/BITS_PER_DIGIT; // Digit position
		    int ibd_dr = ib_dr%BITS_PER_DIGIT; // Bit position in digit
		    r_digits[id_dr] ^= ((denominator->ob_digit[id_d] >> ibd_d) & 1) << ibd_dr;
		}
	    }
	}
    } else {
        // Use Euclidean division based on tabled inverse of NDIV bit chunks
	uint16_t inv_dh;
	// Extract dh = most significant "chunk" of denominator, and invert it.
	// bitsize is MIN(NDIV,nbits_d)
	const int nbits_dh = GF2X_MIN(NDIV,nbits_d);
	{
	    // Extract the highest chunk of denominator
	    int ib_d = nbits_d-1; // Highest bit position in highest digit of denominator
	    uint16_t dh = extract_chunk(denominator->ob_digit, ib_d, nbits_dh, ndigs_d);

	    // Invert dh using tablulated inverse
	    dh <<= (NDIV - nbits_dh);
	    DBG_ASSERT(dh>=(1 << (NDIV-1)) && dh < (1 << NDIV));
	    inv_dh = inv_NDIV[dh - (1 << (NDIV-1))];
	    DBG_ASSERT(inv_dh < (1 << NDIV));
	    inv_dh >>= (NDIV - nbits_dh);
	}
	// inv_dh now contains inverse of dh (nbits_dh bits)

	// Update q and r, processing ndiv bits in each step.
	// ndiv = nbits_dh = min(NDIV,nbits_d), except in the last step where ndiv is smaller to match nbits_d
	// Loop over most significant bit-position in remainder.
	int ib_r_;
        for(int ib_r  = nbits_n - 1; ib_r >= nbits_d - 1; ib_r = ib_r_) {
	    // Compute ib_r_ = next remainder bit position ib_r, after the current iteration
	    if (ib_r > nbits_dh + (nbits_d - 2))
		ib_r_ = ib_r - nbits_dh;
	    else
		ib_r_ = nbits_d - 2;
	    // ndiv is the number of remainder bits processed in this step.
 	    const int ndiv = ib_r - ib_r_;

	    // Extract rh = the remainder chunk to be eliminated. Bitsize is ndiv.
	    uint16_t rh = extract_chunk(r_digits, ib_r, ndiv, ndigs_r);
	    DBG_ASSERT(rh < (1<<10));
	    DBG_ASSERT(inv_dh < (1<<10));
	    
	    // Compute qh = the quotient chunk. Bitsize is ndiv.
	    uint16_t qh;
	    {
		//  qh = (rh*inv(dh))>>(nbits_d-1)
		uint32_t qh_tmp = 
		    (( mul_5_5[rh >> 5  ][inv_dh & 0x1f] ^
		       mul_5_5[rh & 0x1f][inv_dh >> 5  ]) << 5)
		    ^( mul_5_5[rh & 0x1f][inv_dh & 0x1f] )
		    ^( mul_5_5[rh >> 5  ][inv_dh >> 5  ] << 10);
		// qh_tmp is now nbits_dh + ndiv - 1 bits
		qh_tmp >>= (nbits_dh -1);
		// qh_tmp is now ndiv bits
		DBG_ASSERT((int)qh_tmp < (1 << ndiv));
		qh = qh_tmp;
	    }

	    // Update q by inserting qh in the right position
	    int ib_q  = ib_r - (nbits_d - 1);   // Bit position
	    add_chunk(q_digits, ib_q, ndiv, qh, ndigs_q);
	    
	    // Update remainder r -= (qh*d) << (ib_r_ - (nbits_d - 1))
	    // Loop over 5-bit chunks in denominator, starting from least significant end
	    // (the last, most significant chunk of the denominator may be smaller than 5 bits)
	    for(int jb_d = 0; jb_d < nbits_d; jb_d += 5 ) {
		// Note: jb_d is the least significant bit position of the denominator chunk processed in this step
		int ib_d = GF2X_MIN(jb_d + 4, nbits_d - 1);
		int nbits_dc = ib_d - jb_d + 1;
	        // Extract the denominator chunk
		int jd_d  = jb_d/BITS_PER_DIGIT;
		int jbd_d = jb_d%BITS_PER_DIGIT;
		DBG_ASSERT(jd_d < ndigs_d);
	        uint16_t dc = (denominator->ob_digit[jd_d] >> jbd_d) & 0x1f;

		// Multiply qh with denominator chunk
		// The result qhdc is at most ndiv+nbits_dc-1 bits
		DBG_ASSERT(dc<(1<<nbits_dc));
		DBG_ASSERT(qh<(1<<ndiv));
	        uint16_t qhdc = (mul_5_5[dc][qh>>5] << 5) ^ mul_5_5[dc][qh&0x1f];
		int nbits_qhdc = ndiv + nbits_dc -1;
		DBG_ASSERT(qhdc < (1 << nbits_qhdc));

		// Add qhdc to the remainder at the appropriate position
		int ib_qhdc = ib_r - ((nbits_d-1) - jb_d) + (nbits_dc-1);
		add_chunk(r_digits, ib_qhdc, nbits_qhdc, qhdc, ndigs_r);
	    }
#ifdef DEBUG_PYGF2X
	    DBG_ASSERT(extract_chunk(r_digits, ib_r, ndiv, ndigs_r) == 0);
#endif
	}
    }

    DBG_PRINTF_DIGITS("Quotient         :",q_digits,ndigs_q);

    // Remove leading zero digits from remainder
    while(ndigs_r > 0 && r_digits[ndigs_r-1] == 0)
      ndigs_r -= 1;
    DBG_PRINTF_DIGITS("Remainder        :",r_digits,ndigs_r);
    
    PyLongObject *r = _PyLong_New(ndigs_r);
    for(int i=0; i<ndigs_r; i++)
        r->ob_digit[i] = r_digits[i];

    return Py_BuildValue("OO", q, r);
}

PyMethodDef pygf2x_generic_functions[] =
{
    {
        "div",
        pygf2x_div,
        METH_VARARGS,
        "Divide two integers as polynomials over GF(2) (returns quotient and remainder)"
    },
    {
        "mul",
        pygf2x_mul,
        METH_VARARGS,
        "Multiply two integers as polynomials over GF(2)"
    },
    {
        "sqr",
        pygf2x_sqr,
        METH_VARARGS,
        "Square one integer as polynomial over GF(2)"
    },
    {
        NULL,                   // const char  *ml_name;  /* The name of the built-in function/method   */
        NULL,                   // PyCFunction ml_meth;   /* The C function that implements it          */
        0,                      // int         ml_flags;  /* Combination of METH_xxx flags, which mostly*/
                                //                        /* describe the args expected by the C func   */
        NULL                    // const char  *ml_doc;   /* The __doc__ attribute, or NULL             */
    }
};


struct PyModuleDef pygf2x_generic_module =
{
  // Python module definition
    .m_base = PyModuleDef_HEAD_INIT,
    .m_name = "pygf2x_generic",       // Name of the module.
    .m_doc  = NULL,                   // Docstring for the module - in this case empty.
    .m_size = -1,                     // Used by sub-interpreters, if you do not know what
                                      // it is then you do not need it, keep -1 .
    .m_methods = pygf2x_generic_functions,  // Structures of type `PyMethodDef` with functions
                                      // (or "methods") provided by the module.
    .m_slots = NULL,
    .m_traverse = NULL,
    .m_clear = NULL,
    .m_free = NULL
};


PyMODINIT_FUNC PyInit_pygf2x_generic(void)
{
  // Python module initialization
    PyObject *pygf2x = PyModule_Create(&pygf2x_generic_module);

    //PyModule_AddIntConstant(pygf2x, "BITWISE_DIVISION_LIMIT", 5);
    //BITWISE_DIVISION_LIMIT = PyDict_GetItemString(PyModule_GetDict(pygf2x), "BITWISE_DIVISION_LIMIT");
    
    return pygf2x;
}
